package nodes

import (
	"fmt"
	"main/src/blocks"
	"strconv"
	"strings"
)

func MarkdownToHTMLNode(s string) TextNode {
	var node TextNode
	blcks := blocks.MarkdownToBlocks(s)
	bNodes := []TextNode{}

	for _, blck := range blcks {
		bType := blocks.BlockToBlockType(blck)

		switch bType {
		case blocks.Heading:
			trimmed := strings.TrimLeft(blck, "# ")
			n, _ := blocks.HeaderNum(blck)
			children := TextToChildren(trimmed)
			node = TextNode{
				Tag:      "h" + strconv.Itoa(n),
				Children: mapToHTMLChildren(children, 0),
>>>>>>> Stashed changes
			}
			bNodes = append(bNodes, node)

		case blocks.Paragraph:
			cleaned := CleanNewlines(blck)
			children := TextToChildren(cleaned)
			node = TextNode{
				Tag:      "p",
				Children: mapToHTMLChildren(children, 0),
			}
			bNodes = append(bNodes, node)

		case blocks.Code:
			if string(blck[len(blck)-1]) != "\n" {
				blck += "\n"
			}
			child := TextNode{
				Tag:   "code",
				Value: strings.TrimLeft(strings.TrimSuffix(blck, "```\n"), "`\n"),
			}
			node = TextNode{
				Tag:      "pre",
				Children: []TextNode{child},
			}
			bNodes = append(bNodes, node)

		case blocks.Quote:
			joined := CleanQuotes(blck)
			children := TextToChildren(joined)
			node = TextNode{
				Tag:      "blockquote",
				Children: mapToHTMLChildren(children, 0),
			}
			bNodes = append(bNodes, node)

		case blocks.UnorderedList:
			children := CleanLists(blck)
			node = TextNode{
				Tag:      "ul",
				Children: children,
			}
			bNodes = append(bNodes, node)

		case blocks.OrderedList:
			children := CleanLists(blck)
			node = TextNode{
				Tag:      "ol",
				Children: children,
			}
			bNodes = append(bNodes, node)

		default:
			continue
		}
	}

	root := TextNode{Tag: "div", Children: bNodes}
	PrintNodeTree(root, 0)
	return root
}

func PrintNodeTree(node TextNode, depth int) {
	if depth > 50 {
		fmt.Printf("%s[DEPTH LIMIT HIT]\n", strings.Repeat("  ", depth))
		return
	}
	fmt.Printf("%s[%s] Tag: %q, Text: %q, Children: %d\n",
		strings.Repeat("  ", depth), String(node.TextType), node.Tag, node.Text, len(node.Children))

	for _, child := range node.Children {
		PrintNodeTree(child, depth+1)
	}
}
