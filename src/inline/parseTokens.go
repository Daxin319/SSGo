package inline

import (
	"slices"
	"strings"

	"github.com/Daxin319/SSGo/src/nodes"
	"github.com/Daxin319/SSGo/src/tokenizer"
)

type delimRun struct {
	marker string
	pos    int
}

func ParseInlineStack(tokens []tokenizer.Token) []nodes.TextNode {
	var newNodes []nodes.TextNode // initialize textnode and delimrun slices
	var stack []delimRun

	for i := 0; i < len(tokens); {
		t := tokens[i]  // start with the first token
		switch t.Kind { // switch on text type
		case "raw_html":
			// Emit verbatim—no escaping or children—just pass through.
			newNodes = append(newNodes, nodes.TextNode{
				Text:     t.Value,
				TextType: nodes.RawHTML, // treat as plain text in the AST, but Render will print it unescaped
				Url:      "",
				Tag:      "",
				Value:    "",
				Children: nil,
				Props:    nil,
			})
			i++
			continue

		case "code":
			newNodes = append(newNodes, nodes.TextNode{TextType: nodes.Code, Text: t.Value}) // code gets no formatting, append and move on
			i++

		case "![", "[":
			isImage := t.Kind == "!["                      // bool isImage
			j := i + 1                                     // current pos is next token
			for j < len(tokens) && tokens[j].Kind != "]" { // if not the last token and not a closing token
				j++ // move forward to the next token
			}
			altNodes := ParseInlineStack(tokens[i+1 : j])     // parse all tokens from original pos +1 to current token
			if j+1 < len(tokens) && tokens[j+1].Kind == "(" { // if not end of string and parens are in the correct stack locations for Link
				k := j + 2
				for k < len(tokens) && tokens[k].Kind != ")" { // parse until finding closing paren
					k++
				}
				if k < len(tokens) { // handle optional titles
					inner := ""
					for _, tk := range tokens[j+2 : k] {
						inner += tk.Value
					}
					inner = strings.TrimSpace(inner)
					parts := strings.SplitN(inner, " ", 2)
					url := parts[0]
					props := make(map[string]string)
					if len(parts) > 1 {
						rawTitle := parts[1]
						title := strings.Trim(rawTitle, `"'`)
						if title != "" {
							props["title"] = title
						}
					}
					typeEnum := nodes.Link // set enum to link
					if isImage {           // check image bool and change enum to image if true
						typeEnum = nodes.Image
					}
					newNodes = append(newNodes, nodes.TextNode{TextType: typeEnum, Url: url, Props: props, Children: altNodes}) // append nodes generated by parseInlineStack
					i = k + 1                                                                                                   // set index to appropriate token accounting for link/image delimiter
				} else {
					newNodes = append(newNodes, nodes.TextNode{TextType: nodes.Text, Text: t.Value}) // otherwise treat it as plaintext
					i++                                                                              // move forward one token
				}
			} else {
				newNodes = append(newNodes, nodes.TextNode{TextType: nodes.Text, Text: t.Value})
				i++
			}

		case "*", "**", "***", "_", "__", "___", "==":
			stack, newNodes = processDelims(t.Kind, stack, newNodes) // handle this bullshit
			i++                                                      // next token

		case "~~", "~", "^": // strikethrough or subscript or superscript
			m := t.Kind
			closed := false
			for j := len(stack) - 1; j >= 0; j-- {
				if stack[j].marker == m {
					op := stack[j].pos
					content := slices.Clone(newNodes[op:])
					newNodes = newNodes[:op]
					newNodes = append(newNodes, wrap(m, content))
					stack = slices.Delete(stack, j, j+1)
					closed = true
					break
				}
			}
			if !closed {
				stack = append(stack, delimRun{marker: m, pos: len(newNodes)})
			}
			i++

		case "<":
			var href, visible string
			if strings.Contains(t.Value, "@") {
				at := strings.LastIndex(t.Value, "@")
				colon := strings.Index(t.Value, ":")
				if colon != -1 && colon < at {
					// Remove everything from colon up to @
					visible = t.Value[:colon] + t.Value[at:]
					href = "mailto:" + visible
				} else {
					visible = t.Value
					href = "mailto:" + t.Value
				}
			} else {
				href = t.Value
				visible = t.Value
				if strings.HasPrefix(href, "www.") {
					href = "http://" + href
				}
			}
			// Create a link node with the URL as both href and text
			newNodes = append(newNodes, nodes.TextNode{
				TextType: nodes.Link,
				Url:      href,
				Children: []nodes.TextNode{{TextType: nodes.Text, Text: visible}},
			})
			i++

		case "]", "(", ")": // closing link/image brackets and parens
			newNodes = append(newNodes, nodes.TextNode{TextType: nodes.Text, Text: t.Value})
			i++
		default:
			newNodes = append(newNodes, nodes.TextNode{TextType: nodes.Text, Text: t.Value})
			i++
		}
	}

	// Handle any remaining unmatched delimiters by inserting them at their original positions
	for i := len(stack) - 1; i >= 0; i-- {
		op := stack[i].pos
		// Only insert if the position is valid
		if op <= len(newNodes) {
			// Insert the delimiter as plaintext at its original position
			newNodes = slices.Insert(newNodes, op, nodes.TextNode{TextType: nodes.Text, Text: stack[i].marker})
		} else {
			// If position is invalid, append to the end
			newNodes = append(newNodes, nodes.TextNode{TextType: nodes.Text, Text: stack[i].marker})
		}
	}

	return newNodes // return nodes tree
}
